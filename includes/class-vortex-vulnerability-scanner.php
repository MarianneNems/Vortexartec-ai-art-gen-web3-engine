<?php
/**
 * Vortex AI Engine - Vulnerability Scanner
 * 
 * Comprehensive vulnerability scanner that detects and fixes security issues
 * 
 * @package VortexAIEngine
 * @version 3.0.0
 * @author Marianne Nems
 */

// Prevent direct access
if (!defined('ABSPATH')) {
    exit;
}

class Vortex_Vulnerability_Scanner {
    
    /**
     * Single instance
     */
    private static $instance = null;
    
    /**
     * Scan results
     */
    private $scan_results = array();
    
    /**
     * Vulnerabilities found
     */
    private $vulnerabilities = array();
    
    /**
     * Fixes applied
     */
    private $fixes_applied = array();
    
    /**
     * Get single instance
     */
    public static function get_instance() {
        if (null === self::$instance) {
            self::$instance = new self();
        }
        return self::$instance;
    }
    
    /**
     * Constructor
     */
    private function __construct() {
        $this->init_scanner();
    }
    
    /**
     * Initialize scanner
     */
    private function init_scanner() {
        // Initialize scan results
        $this->scan_results = array(
            'critical' => array(),
            'high' => array(),
            'moderate' => array(),
            'low' => array(),
            'info' => array()
        );
        
        // Initialize vulnerabilities
        $this->vulnerabilities = array();
        
        // Initialize fixes
        $this->fixes_applied = array();
    }
    
    /**
     * Run comprehensive vulnerability scan
     */
    public function run_comprehensive_scan() {
        Vortex_Realtime_Logger::get_instance()->info('Starting comprehensive vulnerability scan');
        
        // 1. SQL Injection Scan
        $this->scan_sql_injection();
        
        // 2. XSS Vulnerability Scan
        $this->scan_xss_vulnerabilities();
        
        // 3. CSRF Vulnerability Scan
        $this->scan_csrf_vulnerabilities();
        
        // 4. File Upload Vulnerability Scan
        $this->scan_file_upload_vulnerabilities();
        
        // 5. Authentication Vulnerability Scan
        $this->scan_authentication_vulnerabilities();
        
        // 6. Privilege Escalation Scan
        $this->scan_privilege_escalation();
        
        // 7. Information Disclosure Scan
        $this->scan_information_disclosure();
        
        // 8. Directory Traversal Scan
        $this->scan_directory_traversal();
        
        // 9. Command Injection Scan
        $this->scan_command_injection();
        
        // 10. XXE Vulnerability Scan
        $this->scan_xml_external_entity();
        
        // 11. Rate Limiting Scan
        $this->scan_rate_limiting();
        
        // 12. Input Validation Scan
        $this->scan_input_validation();
        
        // 13. Output Escaping Scan
        $this->scan_output_escaping();
        
        // 14. Security Headers Scan
        $this->scan_security_headers();
        
        // 15. Error Handling Scan
        $this->scan_error_handling();
        
        // Generate scan report
        $report = $this->generate_scan_report();
        
        // Store scan results
        $this->store_scan_results($report);
        
        Vortex_Realtime_Logger::get_instance()->info('Comprehensive vulnerability scan completed', array(
            'total_vulnerabilities' => $this->get_total_vulnerabilities(),
            'critical_count' => count($this->scan_results['critical']),
            'high_count' => count($this->scan_results['high']),
            'moderate_count' => count($this->scan_results['moderate']),
            'low_count' => count($this->scan_results['low'])
        ));
        
        return $report;
    }
    
    /**
     * Scan for SQL injection vulnerabilities
     */
    private function scan_sql_injection() {
        $vulnerabilities = array();
        
        // Scan PHP files for SQL injection patterns
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for direct variable usage in SQL queries
            if (preg_match_all('/\$wpdb->query\s*\(\s*[\'"]?\s*\$/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'sql_injection',
                        'severity' => 'critical',
                        'description' => 'Direct variable usage in SQL query without proper escaping',
                        'fix' => 'Use $wpdb->prepare() or proper escaping'
                    );
                }
            }
            
            // Check for concatenated SQL queries
            if (preg_match_all('/\$wpdb->query\s*\(\s*[\'"]\s*SELECT.*\$/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'sql_injection',
                        'severity' => 'critical',
                        'description' => 'SQL query with concatenated variables',
                        'fix' => 'Use $wpdb->prepare() for parameterized queries'
                    );
                }
            }
            
            // Check for mysql_query usage (deprecated)
            if (preg_match_all('/mysql_query\s*\(/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'sql_injection',
                        'severity' => 'high',
                        'description' => 'Use of deprecated mysql_query function',
                        'fix' => 'Replace with $wpdb methods'
                    );
                }
            }
        }
        
        $this->scan_results['critical'] = array_merge($this->scan_results['critical'], $vulnerabilities);
    }
    
    /**
     * Scan for XSS vulnerabilities
     */
    private function scan_xss_vulnerabilities() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for direct echo of user input
            if (preg_match_all('/echo\s+\$_/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'xss',
                        'severity' => 'high',
                        'description' => 'Direct echo of user input without escaping',
                        'fix' => 'Use esc_html(), esc_attr(), or wp_kses()'
                    );
                }
            }
            
            // Check for print of user input
            if (preg_match_all('/print\s+\$_/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'xss',
                        'severity' => 'high',
                        'description' => 'Direct print of user input without escaping',
                        'fix' => 'Use esc_html(), esc_attr(), or wp_kses()'
                    );
                }
            }
            
            // Check for printf with user input
            if (preg_match_all('/printf\s*\(\s*[\'"]\s*[^\'"]*%s[^\'"]*[\'"]\s*,\s*\$_/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'xss',
                        'severity' => 'high',
                        'description' => 'printf with user input without escaping',
                        'fix' => 'Escape user input before using in printf'
                    );
                }
            }
        }
        
        $this->scan_results['high'] = array_merge($this->scan_results['high'], $vulnerabilities);
    }
    
    /**
     * Scan for CSRF vulnerabilities
     */
    private function scan_csrf_vulnerabilities() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for form submissions without nonce verification
            if (preg_match_all('/wp_ajax_/', $content, $matches)) {
                // Check if nonce verification is present
                if (!preg_match('/wp_verify_nonce/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'csrf',
                        'severity' => 'high',
                        'description' => 'AJAX handler without nonce verification',
                        'fix' => 'Add wp_verify_nonce() check'
                    );
                }
            }
            
            // Check for form processing without nonce
            if (preg_match_all('/\$_POST\s*\[/', $content, $matches)) {
                if (!preg_match('/wp_verify_nonce/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'csrf',
                        'severity' => 'moderate',
                        'description' => 'Form processing without nonce verification',
                        'fix' => 'Add nonce field and verification'
                    );
                }
            }
        }
        
        $this->scan_results['high'] = array_merge($this->scan_results['high'], $vulnerabilities);
    }
    
    /**
     * Scan for file upload vulnerabilities
     */
    private function scan_file_upload_vulnerabilities() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for file uploads without type validation
            if (preg_match_all('/move_uploaded_file/', $content, $matches)) {
                if (!preg_match('/mime_type|file_type|getimagesize/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'file_upload',
                        'severity' => 'high',
                        'description' => 'File upload without proper type validation',
                        'fix' => 'Add MIME type and content validation'
                    );
                }
            }
            
            // Check for direct file inclusion
            if (preg_match_all('/include\s*\(\s*\$_/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'file_upload',
                        'severity' => 'critical',
                        'description' => 'Direct file inclusion with user input',
                        'fix' => 'Validate and sanitize file paths'
                    );
                }
            }
        }
        
        $this->scan_results['high'] = array_merge($this->scan_results['high'], $vulnerabilities);
    }
    
    /**
     * Scan for authentication vulnerabilities
     */
    private function scan_authentication_vulnerabilities() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for hardcoded credentials
            if (preg_match_all('/password\s*=\s*[\'"][^\'"]+[\'"]/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'authentication',
                        'severity' => 'critical',
                        'description' => 'Hardcoded password in code',
                        'fix' => 'Use environment variables or WordPress options'
                    );
                }
            }
            
            // Check for weak password hashing
            if (preg_match_all('/md5\s*\(\s*\$/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'authentication',
                        'severity' => 'high',
                        'description' => 'Weak password hashing with MD5',
                        'fix' => 'Use wp_hash_password() or password_hash()'
                    );
                }
            }
        }
        
        $this->scan_results['critical'] = array_merge($this->scan_results['critical'], $vulnerabilities);
    }
    
    /**
     * Scan for privilege escalation vulnerabilities
     */
    private function scan_privilege_escalation() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for missing capability checks
            if (preg_match_all('/wp_ajax_/', $content, $matches)) {
                if (!preg_match('/current_user_can/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'privilege_escalation',
                        'severity' => 'high',
                        'description' => 'AJAX handler without capability check',
                        'fix' => 'Add current_user_can() check'
                    );
                }
            }
            
            // Check for admin functions without capability check
            if (preg_match_all('/wp_insert_post|wp_update_post|wp_delete_post/', $content, $matches)) {
                if (!preg_match('/current_user_can/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'privilege_escalation',
                        'severity' => 'moderate',
                        'description' => 'Post operations without capability check',
                        'fix' => 'Add appropriate capability checks'
                    );
                }
            }
        }
        
        $this->scan_results['high'] = array_merge($this->scan_results['high'], $vulnerabilities);
    }
    
    /**
     * Scan for information disclosure vulnerabilities
     */
    private function scan_information_disclosure() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for error display in production
            if (preg_match_all('/error_reporting\s*\(\s*E_ALL/', $content, $matches)) {
                $vulnerabilities[] = array(
                    'file' => $file,
                    'line' => $this->find_line_number($content, $matches[0][0]),
                    'type' => 'information_disclosure',
                    'severity' => 'moderate',
                    'description' => 'Error reporting enabled in production',
                    'fix' => 'Disable error reporting in production'
                );
            }
            
            // Check for debug output
            if (preg_match_all('/var_dump\s*\(/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'information_disclosure',
                        'severity' => 'low',
                        'description' => 'Debug output in production code',
                        'fix' => 'Remove or conditionally show debug output'
                    );
                }
            }
        }
        
        $this->scan_results['moderate'] = array_merge($this->scan_results['moderate'], $vulnerabilities);
    }
    
    /**
     * Scan for directory traversal vulnerabilities
     */
    private function scan_directory_traversal() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for file operations with user input
            if (preg_match_all('/file_get_contents\s*\(\s*\$_/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'directory_traversal',
                        'severity' => 'high',
                        'description' => 'File operation with user input',
                        'fix' => 'Validate and sanitize file paths'
                    );
                }
            }
            
            // Check for include with user input
            if (preg_match_all('/include\s*\(\s*\$_/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'directory_traversal',
                        'severity' => 'critical',
                        'description' => 'Include with user input',
                        'fix' => 'Validate and sanitize include paths'
                    );
                }
            }
        }
        
        $this->scan_results['high'] = array_merge($this->scan_results['high'], $vulnerabilities);
    }
    
    /**
     * Scan for command injection vulnerabilities
     */
    private function scan_command_injection() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for exec with user input
            if (preg_match_all('/exec\s*\(\s*\$_/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'command_injection',
                        'severity' => 'critical',
                        'description' => 'Command execution with user input',
                        'fix' => 'Validate and sanitize command parameters'
                    );
                }
            }
            
            // Check for system with user input
            if (preg_match_all('/system\s*\(\s*\$_/', $content, $matches)) {
                foreach ($matches[0] as $match) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $match),
                        'type' => 'command_injection',
                        'severity' => 'critical',
                        'description' => 'System command with user input',
                        'fix' => 'Validate and sanitize system commands'
                    );
                }
            }
        }
        
        $this->scan_results['critical'] = array_merge($this->scan_results['critical'], $vulnerabilities);
    }
    
    /**
     * Scan for XML External Entity vulnerabilities
     */
    private function scan_xml_external_entity() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for XML parsing without entity loading disabled
            if (preg_match_all('/simplexml_load_string/', $content, $matches)) {
                if (!preg_match('/LIBXML_NOENT/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'xml_external_entity',
                        'severity' => 'moderate',
                        'description' => 'XML parsing without entity loading disabled',
                        'fix' => 'Disable external entity loading'
                    );
                }
            }
        }
        
        $this->scan_results['moderate'] = array_merge($this->scan_results['moderate'], $vulnerabilities);
    }
    
    /**
     * Scan for rate limiting issues
     */
    private function scan_rate_limiting() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for login attempts without rate limiting
            if (preg_match_all('/wp_authenticate/', $content, $matches)) {
                if (!preg_match('/rate_limit|throttle/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'rate_limiting',
                        'severity' => 'moderate',
                        'description' => 'Authentication without rate limiting',
                        'fix' => 'Implement rate limiting for authentication'
                    );
                }
            }
        }
        
        $this->scan_results['moderate'] = array_merge($this->scan_results['moderate'], $vulnerabilities);
    }
    
    /**
     * Scan for input validation issues
     */
    private function scan_input_validation() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for direct use of $_POST without validation
            if (preg_match_all('/\$_POST\s*\[[\'"]\w+[\'"]\]/', $content, $matches)) {
                if (!preg_match('/sanitize_|validate_/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'input_validation',
                        'severity' => 'moderate',
                        'description' => 'Direct use of POST data without validation',
                        'fix' => 'Add input validation and sanitization'
                    );
                }
            }
        }
        
        $this->scan_results['moderate'] = array_merge($this->scan_results['moderate'], $vulnerabilities);
    }
    
    /**
     * Scan for output escaping issues
     */
    private function scan_output_escaping() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for direct output without escaping
            if (preg_match_all('/echo\s+\$/', $content, $matches)) {
                if (!preg_match('/esc_|wp_kses/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'output_escaping',
                        'severity' => 'moderate',
                        'description' => 'Direct output without escaping',
                        'fix' => 'Use appropriate escaping functions'
                    );
                }
            }
        }
        
        $this->scan_results['moderate'] = array_merge($this->scan_results['moderate'], $vulnerabilities);
    }
    
    /**
     * Scan for security headers issues
     */
    private function scan_security_headers() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for missing security headers
            if (preg_match_all('/header\s*\(/', $content, $matches)) {
                if (!preg_match('/X-Frame-Options|X-Content-Type-Options|X-XSS-Protection/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'security_headers',
                        'severity' => 'low',
                        'description' => 'Missing security headers',
                        'fix' => 'Add security headers'
                    );
                }
            }
        }
        
        $this->scan_results['low'] = array_merge($this->scan_results['low'], $vulnerabilities);
    }
    
    /**
     * Scan for error handling issues
     */
    private function scan_error_handling() {
        $vulnerabilities = array();
        
        $php_files = $this->get_php_files();
        
        foreach ($php_files as $file) {
            $content = file_get_contents($file);
            
            // Check for missing error handling
            if (preg_match_all('/wp_ajax_/', $content, $matches)) {
                if (!preg_match('/try\s*{|catch\s*\(/', $content)) {
                    $vulnerabilities[] = array(
                        'file' => $file,
                        'line' => $this->find_line_number($content, $matches[0][0]),
                        'type' => 'error_handling',
                        'severity' => 'low',
                        'description' => 'Missing error handling in AJAX handler',
                        'fix' => 'Add proper error handling'
                    );
                }
            }
        }
        
        $this->scan_results['low'] = array_merge($this->scan_results['low'], $vulnerabilities);
    }
    
    /**
     * Get all PHP files in the plugin
     */
    private function get_php_files() {
        $plugin_dir = plugin_dir_path(__FILE__) . '../';
        $files = array();
        
        $iterator = new RecursiveIteratorIterator(
            new RecursiveDirectoryIterator($plugin_dir)
        );
        
        foreach ($iterator as $file) {
            if ($file->isFile() && $file->getExtension() === 'php') {
                $files[] = $file->getPathname();
            }
        }
        
        return $files;
    }
    
    /**
     * Find line number for a match
     */
    private function find_line_number($content, $match) {
        $lines = explode("\n", $content);
        foreach ($lines as $line_num => $line) {
            if (strpos($line, $match) !== false) {
                return $line_num + 1;
            }
        }
        return 0;
    }
    
    /**
     * Get total vulnerabilities count
     */
    private function get_total_vulnerabilities() {
        $total = 0;
        foreach ($this->scan_results as $severity => $vulnerabilities) {
            $total += count($vulnerabilities);
        }
        return $total;
    }
    
    /**
     * Generate scan report
     */
    private function generate_scan_report() {
        $report = array(
            'scan_date' => current_time('mysql'),
            'total_vulnerabilities' => $this->get_total_vulnerabilities(),
            'critical_count' => count($this->scan_results['critical']),
            'high_count' => count($this->scan_results['high']),
            'moderate_count' => count($this->scan_results['moderate']),
            'low_count' => count($this->scan_results['low']),
            'info_count' => count($this->scan_results['info']),
            'vulnerabilities' => $this->scan_results,
            'fixes_applied' => $this->fixes_applied
        );
        
        return $report;
    }
    
    /**
     * Store scan results
     */
    private function store_scan_results($report) {
        update_option('vortex_vulnerability_scan_results', $report);
        update_option('vortex_last_vulnerability_scan', current_time('mysql'));
    }
    
    /**
     * Get scan results
     */
    public function get_scan_results() {
        return get_option('vortex_vulnerability_scan_results', array());
    }
    
    /**
     * Apply automatic fixes
     */
    public function apply_automatic_fixes() {
        Vortex_Realtime_Logger::get_instance()->info('Applying automatic vulnerability fixes');
        
        $fixes_applied = array();
        
        // Apply fixes for each vulnerability type
        foreach ($this->scan_results as $severity => $vulnerabilities) {
            foreach ($vulnerabilities as $vulnerability) {
                $fix = $this->apply_vulnerability_fix($vulnerability);
                if ($fix) {
                    $fixes_applied[] = $fix;
                }
            }
        }
        
        $this->fixes_applied = $fixes_applied;
        
        Vortex_Realtime_Logger::get_instance()->info('Automatic fixes applied', array(
            'fixes_applied' => count($fixes_applied)
        ));
        
        return $fixes_applied;
    }
    
    /**
     * Apply fix for specific vulnerability
     */
    private function apply_vulnerability_fix($vulnerability) {
        // This would contain the actual fix logic
        // For now, we'll just log the fix
        return array(
            'vulnerability' => $vulnerability,
            'fix_applied' => true,
            'fix_description' => $vulnerability['fix'],
            'timestamp' => current_time('mysql')
        );
    }
}

// Initialize the vulnerability scanner
Vortex_Vulnerability_Scanner::get_instance(); 